'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.1.1
// Imports
var CSON, extractOptsAndCallback, fsUtil, pathUtil, requireFresh;

fsUtil = require('safefs');

pathUtil = require('path');

extractOptsAndCallback = require('extract-opts');

requireFresh = require('requirefresh');

// Public: The exported CSON singleton
CSON = function () {
  function CSON() {
    _classCallCheck(this, CSON);
  }

  _createClass(CSON, [{
    key: 'ensureErrorType',

    // ====================================
    // Helpers

    // Internal: Ensure Error Type
    value: function ensureErrorType(err) {
      if (err instanceof Error) {
        return err;
      } else {
        return this.ensureErrorType(err);
      }
    }

    // Internal: Complete with callback if it exists

  }, {
    key: 'complete',
    value: function complete(result, next) {
      // Complete
      if (next) {
        if (result instanceof Error) {
          next(result);
        } else {
          next(null, result);
        }
        return this;
      } else {
        return result;
      }
    }

    // Internal: Fills in any missing options for use in our methods

    // opts - {Object} The options to prepare

    // Returns the same opts {Object} that we received

  }, {
    key: 'getOptions',
    value: function getOptions() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (opts.format == null) {
        opts.format = null;
      }
      if (opts.filename == null) {
        opts.filename = null;
      }
      if (opts.filename) {
        opts.filename = pathUtil.resolve(opts.filename);
        if (opts.format == null) {
          opts.format = this.getFormat(opts.filename);
        }
      }
      if (opts.json == null) {
        opts.json = true;
      }
      if (opts.cson == null) {
        opts.cson = true;
      }
      if (opts.javascript == null) {
        opts.javascript = false;
      }
      if (opts.coffeescript == null) {
        opts.coffeescript = false;
      }
      return opts;
    }

    // Internal: Gets the format for a file name or path

    // file - {String} to get the format for

    // Returns the determined format as a {String} ("json", "cson", "coffeescript", or "javascript", or null)

  }, {
    key: 'getFormat',
    value: function getFormat(file) {
      switch (pathUtil.extname(file)) {
        case '.json':
          return 'json';
        case '.cson':
          return 'cson';
        case '.coffee':
          return 'coffeescript';
        case '.js':
          return 'javascript';
        default:
          return null;
      }
    }

    // Internal: Helper for {::createString}, {::parseString}, {::parseFile}, {::requireFile}

  }, {
    key: 'action',
    value: function action(args) {
      var action, data, next, opts, prefix, ref, result, suffix;
      // Prepare
      action = args.action;
      prefix = args.prefix;
      suffix = args.suffix;
      data = args.data;
      opts = args.opts;
      next = args.next;

      if (suffix == null) {
        suffix = '';
      }

      // Prepare options
      var _extractOptsAndCallba = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba2 = _slicedToArray(_extractOptsAndCallba, 2);

      opts = _extractOptsAndCallba2[0];
      next = _extractOptsAndCallba2[1];
      switch (action) {
        case 'requireFile':
        case 'parseFile':
          if (opts.filename == null) {
            opts.filename = data;
          }
      }
      // Add defaults
      opts = this.getOptions(opts);
      // Default: CSON
      if ((ref = opts.format) === null || ref === 'cson') {
        if (opts.cson === true) {
          result = this[prefix + 'CSON' + suffix](data, opts);
        } else {
          result = new Error('CSON.' + action + ': Desired format is CSON however CSON is disabled by an option');
        }
        // JSON
      } else if (opts.format === 'json') {
        if (opts.json === true) {
          result = this[prefix + 'JSON' + suffix](data, opts);
        } else {
          result = new Error('CSON.' + action + ': Desired format is JSON however JSON is disabled by an option');
        }
        // JavaScript
      } else if (opts.format === 'javascript') {
        if (opts.javascript === true) {
          result = this[prefix + 'JS' + suffix](data, opts);
        } else {
          result = new Error('CSON.' + action + ': Desired format is JavaScript however JavaScript is disabled by an option');
        }
        // CoffeeScript
      } else if (opts.format === 'coffeescript') {
        if (opts.coffeescript === true) {
          result = this[prefix + 'CS' + suffix](data, opts);
        } else {
          result = new Error('CSON.' + action + ': Desired format is CoffeeScript however CoffeeScript is disabled by an option');
        }
      } else {
        result = new Error('CSON.' + action + ': Desired format is not supported');
      }
      // Complete
      return this.complete(result, next);
    }

    // ====================================
    // Bundles

    // Public: {Delegates to: .createString}

  }, {
    key: 'stringify',
    value: function stringify(data, replacer, indent) {
      var opts;
      opts = {};
      opts.replacer = replacer;
      opts.indent = indent;
      return this.createCSONString(data, opts);
    }

    // Public: {Delegates to: .parseCSONString}

  }, {
    key: 'parse',
    value: function parse(data, opts, next) {
      return this.parseCSONString(data, opts, next);
    }

    // Public: {Delegates to: .parseCSONFile}

  }, {
    key: 'load',
    value: function load(data, opts, next) {
      return this.parseCSONFile(data, opts, next);
    }

    // Public: Converts an {Object} into a {String} of the desired format

    // If the format option is not specified, we default to CSON

    // data - {Object} The data to convert
    // opts - {Object} The options (options may also be forwarded onto the parser library)
    //        :format - {String} The format to use: "cson" (default), "json", "coffeescript", or "javascript"
    //        :cson - {Boolean} Whether or not the CSON format should be allowed (defaults to `true`)
    //        :json - {Boolean} Whether or not the JSON format should be allowed (defaults to `true`)

    // Returns {String} or {Error}

  }, {
    key: 'createString',
    value: function createString(data, opts, next) {
      return this.action({
        action: 'createString',
        prefix: 'create',
        suffix: 'String',
        data: data,
        opts: opts,
        next: next
      });
    }

    // Public: Converts a {String} of the desired format into an {Object}

    // If the format option is not specified, we default to CSON

    // data - {String} The string to parse
    // opts - {Object} The options (options may also be forwarded onto the parser library)
    //        :format - {String} The format to use: "cson" (default), "json", "coffeescript", or "javascript"
    //        :cson - {Boolean} Whether or not the CSON format should be allowed (defaults to `true`)
    //        :json - {Boolean} Whether or not the JSON format should be allowed (defaults to `true`)
    //        :coffeescript - {Boolean} Whether or not the CoffeeScript format should be allowed (defaults to `false`)
    //        :json - {Boolean} Whether or not the CoffeeScript format should be allowed (defaults to `json`)

    // Returns {Object} or {Error}

  }, {
    key: 'parseString',
    value: function parseString(data, opts, next) {
      return this.action({
        action: 'parseString',
        prefix: 'parse',
        suffix: 'String',
        data: data,
        opts: opts,
        next: next
      });
    }

    // Public: Parses a file path of the desired format into an {Object}

    // If the format option is not specified, we use the filename to detect what it should be, otherwise we default to CSON

    // data - {String} The file path to parse
    // opts - {Object} The options (options may also be forwarded onto the parser library)
    //        :format - {String} The format to use: "cson" (default), "json", "coffeescript", or "javascript"
    //        :cson - {Boolean} Whether or not the CSON format should be allowed (defaults to `true`)
    //        :json - {Boolean} Whether or not the JSON format should be allowed (defaults to `true`)
    //        :coffeescript - {Boolean} Whether or not the CoffeeScript format should be allowed (defaults to `false`)
    //        :json - {Boolean} Whether or not the CoffeeScript format should be allowed (defaults to `json`)

    // Returns {Object} or {Error}

  }, {
    key: 'parseFile',
    value: function parseFile(data, opts, next) {
      return this.action({
        action: 'parseFile',
        prefix: 'parse',
        suffix: 'File',
        data: data,
        opts: opts,
        next: next
      });
    }

    // Public: Requires or parses a file path of the desired format into an {Object}

    // If the format option is not specified, we use the filename to detect what it should be, otherwise we default to CSON

    // data - {String} The file path to require or parse
    // opts - {Object} The options (options may also be forwarded onto the parser library)
    //        :format - {String} The format to use: "cson" (default), "json", "coffeescript", or "javascript"
    //        :cson - {Boolean} Whether or not the CSON format should be allowed (defaults to `true`)
    //        :json - {Boolean} Whether or not the JSON format should be allowed (defaults to `true`)
    //        :coffeescript - {Boolean} Whether or not the CoffeeScript format should be allowed (defaults to `false`)
    //        :json - {Boolean} Whether or not the CoffeeScript format should be allowed (defaults to `json`)

    // Returns {Object} or {Error}

  }, {
    key: 'requireFile',
    value: function requireFile(data, opts, next) {
      return this.action({
        action: 'requireFile',
        prefix: 'require',
        suffix: 'File',
        data: data,
        opts: opts,
        next: next
      });
    }

    // ====================================
    // Creating Strings from Objects

    // Public: Converts an {Object} into a JSON {String}

    // data - {Object} The data to convert
    // opts - {Object} The options (options may also be forwarded onto the parser library)
    //        :replacer - {Boolean} The replacer option for `JSON.stringify` (defaults to `null`)
    //        :indent - {Boolean} The indent option for `JSON.stringify` (defaults to two spaces `  `)

    // Returns {String} or {Error}

  }, {
    key: 'createJSONString',
    value: function createJSONString(data, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba3 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba4 = _slicedToArray(_extractOptsAndCallba3, 2);

      opts = _extractOptsAndCallba4[0];
      next = _extractOptsAndCallba4[1];

      opts = this.getOptions(opts);
      if (opts.replacer == null) {
        opts.replacer = null;
      }
      if (opts.indent == null) {
        opts.indent = '  ';
      }
      try {
        // Stringify
        result = JSON.stringify(data, opts.replacer, opts.indent);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Converts an {Object} into a CSON {String}

    // data - {Object} The data to convert
    // opts - {Object} The options (options may also be forwarded onto the parser library)
    //        :replacer - {Boolean} The replacer option for `require('cson-parser').stringify` (defaults to `null`)
    //        :indent - {Boolean} The indent option for `require('cson-parser').stringify` (defaults to a single tab `'\t'`)

    // Returns {String} or {Error}

  }, {
    key: 'createCSONString',
    value: function createCSONString(data, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba5 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba6 = _slicedToArray(_extractOptsAndCallba5, 2);

      opts = _extractOptsAndCallba6[0];
      next = _extractOptsAndCallba6[1];

      opts = this.getOptions(opts);
      if (opts.replacer == null) {
        opts.replacer = null;
      }
      if (opts.indent == null) {
        opts.indent = '\t';
      }
      try {
        // Stringify
        result = require('cson-parser').stringify(data, opts.replacer, opts.indent);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // Private: Not yet supported

  }, {
    key: 'createCSString',
    value: function createCSString(data, opts, next) {
      var result;
      // Prepare

      // Stringify
      var _extractOptsAndCallba7 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba8 = _slicedToArray(_extractOptsAndCallba7, 2);

      opts = _extractOptsAndCallba8[0];
      next = _extractOptsAndCallba8[1];
      result = new Error('CSON.createCS: Creating CoffeeScript code is not yet supported');
      // Complete
      return this.complete(result, next);
    }

    /*
    Potentially we could use something like the following from CSON v1
    However the JSON.stringify gets rid of functions...
    which is the entire point of the coffeescript mode over the CSON mode...
    So until we figure out how to toString() an object and keep the functions intact,
    unsafe stringifying to CSON or CS or JS won't happen.
     Perhaps https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource
    will be of use one day
     src = "var result = #{JSON.stringify obj}"
    result = require('js2coffee').build(src, opts).code
    result = result.replace(/^\s*result\s*\=\s/, '')
    if /^\s/.test(result) is false
    	result = result.trim()
    if typeof obj is 'object'
    	unless Array.isArray(obj)
    		result = '{'+result+'}'  unless result is '{}'
    return result
    */
    // Private: Not yet supported

  }, {
    key: 'createJSString',
    value: function createJSString(data, opts, next) {
      var result;
      // Prepare

      // Stringify
      var _extractOptsAndCallba9 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba10 = _slicedToArray(_extractOptsAndCallba9, 2);

      opts = _extractOptsAndCallba10[0];
      next = _extractOptsAndCallba10[1];
      result = new Error('CSON.createJS: Creating JavaScript code is not yet supported');
      // Complete
      return this.complete(result, next);
    }

    // ====================================
    // Parsing Strings to Objects

    // Public: Parses a JSON {String} into an {Object}

    // data - The JSON {String} to parse
    // opts - {Object} The options, unused

    // Returns {Object} or {Error}

  }, {
    key: 'parseJSONString',
    value: function parseJSONString(data, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba11 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba12 = _slicedToArray(_extractOptsAndCallba11, 2);

      opts = _extractOptsAndCallba12[0];
      next = _extractOptsAndCallba12[1];

      try {
        // Parse
        result = JSON.parse(data);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Parses a CSON {String} into an {Object}

    // data - The CSON {String} to parse
    // opts - {Object} The options, unused

    // Returns {Object} or {Error}

  }, {
    key: 'parseCSONString',
    value: function parseCSONString(data, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba13 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba14 = _slicedToArray(_extractOptsAndCallba13, 2);

      opts = _extractOptsAndCallba14[0];
      next = _extractOptsAndCallba14[1];

      try {
        // Parse
        result = require('cson-parser').parse(data);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Parses a JavaScript {String} into an {Object}

    // data - The JavaScript {String} to parse
    // opts - {Object} The options (also passed to require('vm').runInNewContex)
    //        :context - {Object} The context option that is used in `require('vm').runInNewContext`, defaults to an empty object `{}`

    // Returns {Object} or {Error}

  }, {
    key: 'parseJSString',
    value: function parseJSString(data, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba15 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba16 = _slicedToArray(_extractOptsAndCallba15, 2);

      opts = _extractOptsAndCallba16[0];
      next = _extractOptsAndCallba16[1];

      opts = this.getOptions(opts);
      if (opts.context == null) {
        opts.context = {};
      }
      try {
        // Parse
        result = require('vm').runInNewContext(data, opts.context, opts);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Parses a CoffeeScript {String} into an {Object}

    // data - The CoffeeScript {String} to parse
    // opts - {Object} The options, forwarded onto `require('coffee-script').eval`

    // Returns {Object} or {Error}

  }, {
    key: 'parseCSString',
    value: function parseCSString(data, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba17 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba18 = _slicedToArray(_extractOptsAndCallba17, 2);

      opts = _extractOptsAndCallba18[0];
      next = _extractOptsAndCallba18[1];

      opts = this.getOptions(opts);
      try {
        // Parse
        result = require('coffee-script').eval(data, opts);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // ====================================
    // Parsing Files to Objects

    // Public: Parses a JSON file into an {Object}

    // data - {String} The file path to parse
    // opts - {Object} The options, forwarded onto {::parseJSONString}

    // Returns {Object} or {Error}

  }, {
    key: 'parseJSONFile',
    value: function parseJSONFile(file, opts, next) {
      var result;
      // Prepare

      // Parse
      var _extractOptsAndCallba19 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba20 = _slicedToArray(_extractOptsAndCallba19, 2);

      opts = _extractOptsAndCallba20[0];
      next = _extractOptsAndCallba20[1];
      result = fsUtil.readFileSync(file);
      if (result instanceof Error) {
        result = result;
      } else {
        result = this.parseJSONString(result.toString(), opts);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Parses a CSON file into an {Object}

    // data - {String} The file path to parse
    // opts - {Object} The options, forwarded onto {::parseCSONString}

    // Returns {Object} or {Error}

  }, {
    key: 'parseCSONFile',
    value: function parseCSONFile(file, opts, next) {
      var result;
      // Prepare

      // Parse
      var _extractOptsAndCallba21 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba22 = _slicedToArray(_extractOptsAndCallba21, 2);

      opts = _extractOptsAndCallba22[0];
      next = _extractOptsAndCallba22[1];
      result = fsUtil.readFileSync(file);
      if (result instanceof Error) {
        result = result;
      } else {
        result = this.parseCSONString(result.toString(), opts);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Parses a JAvaScript file into an {Object}

    // data - {String} The file path to parse
    // opts - {Object} The options, forwarded onto {::parseJSString}

    // Returns {Object} or {Error}

  }, {
    key: 'parseJSFile',
    value: function parseJSFile(file, opts, next) {
      var result;
      // Prepare

      // Parse
      var _extractOptsAndCallba23 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba24 = _slicedToArray(_extractOptsAndCallba23, 2);

      opts = _extractOptsAndCallba24[0];
      next = _extractOptsAndCallba24[1];
      result = fsUtil.readFileSync(file);
      if (result instanceof Error) {
        result = result;
      } else {
        result = this.parseJSString(result.toString(), opts);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Parses a CoffeeScript file into an {Object}

    // data - {String} The file path to parse
    // opts - {Object} The options, forwarded onto {::parseCSString}

    // Returns {Object} or {Error}

  }, {
    key: 'parseCSFile',
    value: function parseCSFile(file, opts, next) {
      var result;
      // Prepare

      // Parse
      var _extractOptsAndCallba25 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba26 = _slicedToArray(_extractOptsAndCallba25, 2);

      opts = _extractOptsAndCallba26[0];
      next = _extractOptsAndCallba26[1];
      result = fsUtil.readFileSync(file);
      if (result instanceof Error) {
        result = result;
      } else {
        result = this.parseCSString(result.toString(), opts);
      }
      // Complete
      return this.complete(result, next);
    }

    // ====================================
    // Requiring Files to Objects

    // Public: {Delegates to: .parseJSONFile}

  }, {
    key: 'requireJSONFile',
    value: function requireJSONFile(file, opts, next) {
      var result;
      // Prepare

      // Require
      var _extractOptsAndCallba27 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba28 = _slicedToArray(_extractOptsAndCallba27, 2);

      opts = _extractOptsAndCallba28[0];
      next = _extractOptsAndCallba28[1];
      result = this.parseJSONFile(file, opts);
      // Complete
      return this.complete(result, next);
    }

    // Public: {Delegates to: .parseCSONFile}

  }, {
    key: 'requireCSONFile',
    value: function requireCSONFile(file, opts, next) {
      var result;
      // Prepare

      // Require
      var _extractOptsAndCallba29 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba30 = _slicedToArray(_extractOptsAndCallba29, 2);

      opts = _extractOptsAndCallba30[0];
      next = _extractOptsAndCallba30[1];
      result = this.parseCSONFile(file, opts);
      // Complete
      return this.complete(result, next);
    }

    // Public: Requires a JavaScript file and returns the result {Object}

    // data - {String} The file path to require
    // opts - {Object} The options, unused

    // Returns {Object} or {Error}

  }, {
    key: 'requireJSFile',
    value: function requireJSFile(file, opts, next) {
      var err, result;
      // Prepare

      var _extractOptsAndCallba31 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba32 = _slicedToArray(_extractOptsAndCallba31, 2);

      opts = _extractOptsAndCallba32[0];
      next = _extractOptsAndCallba32[1];

      try {
        // Require
        result = requireFresh(file);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }

    // Public: Requires a CoffeeScript file and returns the result {Object}

    // data - {String} The file path to require
    // opts - {Object} The options, unused

    // Returns {Object} or {Error}

  }, {
    key: 'requireCSFile',
    value: function requireCSFile(file, opts, next) {
      var err, result;
      // Prepare

      // Require
      var _extractOptsAndCallba33 = extractOptsAndCallback(opts, next);

      var _extractOptsAndCallba34 = _slicedToArray(_extractOptsAndCallba33, 2);

      opts = _extractOptsAndCallba34[0];
      next = _extractOptsAndCallba34[1];
      require('coffee-script/register');
      try {
        result = requireFresh(file);
      } catch (error) {
        err = error;
        result = this.ensureErrorType(err);
      }
      // Complete
      return this.complete(result, next);
    }
  }]);

  return CSON;
}();

// Export
module.exports = new CSON();